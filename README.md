# sluice

The landscape of distributed messaging is bifurcated. On one end of the spectrum lie heavy, cluster-native systems like Apache Kafka, designed for massive throughput and infinite retention but demanding significant operational overhead—ZooKeeper dependencies, JVM tuning, and complex partition management. On the other end are lightweight, ephemeral systems like NATS (Core) or Redis Pub/Sub, which offer operational simplicity but often sacrifice strict durability or require complex add-ons (like NATS JetStream) to achieve persistence.

Sluice is proposed as a distinct "middle way." It targets the architectural gap for a broker that offers the operational simplicity of a single binary (like SQLite) while providing "good enough" durability and performance (5,000+ msg/s) for the 90% of use cases that do not require petabyte-scale ingestion. The defining characteristic of Sluice, however, is not its storage engine but its approach to Application-Level Backpressure. By mandating explicit flow control via gRPC bidirectional streaming, Sluice shifts the burden of queue management from the broker’s memory to the producer’s capability, ensuring system stability under varying load conditions.
